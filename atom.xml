<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Longford&#39;s Space</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.helongfei.com/"/>
  <updated>2019-07-14T13:05:00.455Z</updated>
  <id>http://www.helongfei.com/</id>
  
  <author>
    <name>贺龙飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过源码学习 Go 的生命周期</title>
    <link href="http://www.helongfei.com/2019/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-go-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://www.helongfei.com/2019/通过源码学习-go-的生命周期/</id>
    <published>2019-07-14T08:26:00.000Z</published>
    <updated>2019-07-14T13:05:00.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当我们学习一个新事物时，一定要做到「知其然知其所以然」。最近看了一些 go 的源码，对 go 的设计有了更深的认识，也让自己在工作中使用的更得心应手。</p><a id="more"></a><p>本文基于以下版本：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version go1.12.7 darwin/amd64</span><br></pre></td></tr></table></figure></p><h2 id="四个重要结构"><a href="#四个重要结构" class="headerlink" title="四个重要结构"></a>四个重要结构</h2><p>首先，我们了解下这四个核心的 struct，有助于帮助我们理解下文。</p><h3 id="schedt"><a href="#schedt" class="headerlink" title="schedt"></a>schedt</h3><blockquote><p>src/runtime/runtime2.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// M 相关</span></span><br><span class="line">  midle        muintptr <span class="comment">// idle m's waiting for work</span></span><br><span class="line">  nmidle       <span class="keyword">int32</span>    <span class="comment">// number of idle m's waiting for work</span></span><br><span class="line">  nmidlelocked <span class="keyword">int32</span>    <span class="comment">// number of locked m's waiting for work</span></span><br><span class="line">  mnext        <span class="keyword">int64</span>    <span class="comment">// number of m's that have been created and next M ID</span></span><br><span class="line">  maxmcount    <span class="keyword">int32</span>    <span class="comment">// maximum number of m's allowed (or die)</span></span><br><span class="line">  nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">  nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// P 相关</span></span><br><span class="line">  pidle      puintptr <span class="comment">// idle p's</span></span><br><span class="line">  npidle     <span class="keyword">uint32</span></span><br><span class="line">  nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// G 全局队列</span></span><br><span class="line">  runq     gQueue</span><br><span class="line">  runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Global cache of dead G's.</span></span><br><span class="line">  gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock    mutex</span><br><span class="line">    stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">    noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">    n       <span class="keyword">int32</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待释放的 M 列表</span></span><br><span class="line">  freem *m</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// GC 、sysmon相关</span></span><br><span class="line">  gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run</span></span><br><span class="line">  stopwait   <span class="keyword">int32</span></span><br><span class="line">  stopnote   note</span><br><span class="line">  sysmonwait <span class="keyword">uint32</span></span><br><span class="line">  sysmonnote note</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g"><a href="#g" class="headerlink" title="g"></a>g</h3><blockquote><p>src/runtime/runtime2.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// stack 相关</span></span><br><span class="line">stack       stack   <span class="comment">// offset known to runtime/cgo</span></span><br><span class="line">stackguard0 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">stackguard1 <span class="keyword">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前关联的 M</span></span><br><span class="line">m              *m      <span class="comment">// current m; offset known to arm liblink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数地址</span></span><br><span class="line">param          unsafe.Pointer <span class="comment">// passed parameter on wakeup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GC 相关</span></span><br><span class="line">preemptscan    <span class="keyword">bool</span>       <span class="comment">// preempted g does scan for gc</span></span><br><span class="line">gcscandone     <span class="keyword">bool</span>       <span class="comment">// g has scanned stack; protected by _Gscan bit in status</span></span><br><span class="line">gcscanvalid    <span class="keyword">bool</span>       <span class="comment">// false at start of gc cycle, true if G has not run since last scan; <span class="doctag">TODO:</span> remove?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器</span></span><br><span class="line">timer          *timer         <span class="comment">// cached timer for time.Sleep</span></span><br><span class="line"><span class="comment">// select</span></span><br><span class="line">selectDone     <span class="keyword">uint32</span>         <span class="comment">// are we participating in a select and did someone win the race?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-G GC state</span></span><br><span class="line">gcAssistBytes <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="m"><a href="#m" class="headerlink" title="m"></a>m</h3><blockquote><p>src/runtime/runtime2.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P 相关</span></span><br><span class="line">p             puintptr <span class="comment">// attached p for executing go code (nil if not executing go code)</span></span><br><span class="line">nextp         puintptr</span><br><span class="line">oldp          puintptr <span class="comment">// the p that was attached before executing a syscall</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// M 自旋状态</span></span><br><span class="line">spinning      <span class="keyword">bool</span> <span class="comment">// m is out of work and is actively looking for work</span></span><br><span class="line">blocked       <span class="keyword">bool</span> <span class="comment">// m is blocked on a note</span></span><br><span class="line">inwb          <span class="keyword">bool</span> <span class="comment">// m is executing a write barrier</span></span><br><span class="line">newSigstack   <span class="keyword">bool</span> <span class="comment">// minit on C thread called sigaltstack</span></span><br><span class="line">printlock     <span class="keyword">int8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cgo</span></span><br><span class="line">incgo         <span class="keyword">bool</span>   <span class="comment">// m is executing a cgo call</span></span><br><span class="line"><span class="comment">// 等待 G 的数量</span></span><br><span class="line">freeWait      <span class="keyword">uint32</span> <span class="comment">// if == 0, safe to free g0 and delete m (atomic)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cgo</span></span><br><span class="line">ncgocall      <span class="keyword">uint64</span>      <span class="comment">// number of cgo calls in total</span></span><br><span class="line">ncgo          <span class="keyword">int32</span>       <span class="comment">// number of cgo calls currently in progress</span></span><br><span class="line">cgoCallersUse <span class="keyword">uint32</span>      <span class="comment">// if non-zero, cgoCallers in use temporarily</span></span><br><span class="line">cgoCallers    *cgoCallers <span class="comment">// cgo traceback if crashing in cgo call</span></span><br><span class="line"></span><br><span class="line">park          note</span><br><span class="line"></span><br><span class="line">createstack   [<span class="number">32</span>]<span class="keyword">uintptr</span>    <span class="comment">// stack that created this thread.</span></span><br><span class="line">lockedExt     <span class="keyword">uint32</span>         <span class="comment">// tracking for external LockOSThread</span></span><br><span class="line">lockedInt     <span class="keyword">uint32</span>         <span class="comment">// tracking for internal lockOSThread</span></span><br><span class="line">nextwaitm     muintptr       <span class="comment">// next m waiting for lock</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OS 线程</span></span><br><span class="line">thread        <span class="keyword">uintptr</span> <span class="comment">// thread handle</span></span><br><span class="line"><span class="comment">// 待释放的 M</span></span><br><span class="line">freelink      *m      <span class="comment">// on sched.freem</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="p"><a href="#p" class="headerlink" title="p"></a>p</h3><blockquote><p>src/runtime/runtime2.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 相关联的 M</span></span><br><span class="line">m           muintptr   <span class="comment">// back-link to associated m (nil if idle)</span></span><br><span class="line">mcache      *mcache</span><br><span class="line">racectx     <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// G 本地队列</span></span><br><span class="line"><span class="comment">// Queue of runnable goroutines. Accessed without lock.</span></span><br><span class="line">runqhead <span class="keyword">uint32</span></span><br><span class="line">runqtail <span class="keyword">uint32</span></span><br><span class="line">runq     [<span class="number">256</span>]guintptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下个可被执行的 G</span></span><br><span class="line">runnext guintptr</span><br><span class="line"></span><br><span class="line"><span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">   gList</span><br><span class="line">   n <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sudog 相关</span></span><br><span class="line">sudogcache []*sudog</span><br><span class="line">sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-P GC state</span></span><br><span class="line">gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker</span></span><br><span class="line">gcBgMarkWorker       guintptr</span><br><span class="line">gcMarkWorkerMode     gcMarkWorkerMode</span><br><span class="line"></span><br><span class="line"><span class="comment">// gcMarkWorkerStartTime is the nanotime() at which this mark</span></span><br><span class="line"><span class="comment">// worker started.</span></span><br><span class="line">gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line"><span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line"><span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">gcw gcWork</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Go 启动引导文件是汇编写的，根据不同的系统，引导文件不同；文件存放于 runtime/asm_*.s:</p><figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CALL</span>runtime·args(<span class="built_in">SB</span>)</span><br><span class="line"><span class="symbol">CALL</span>runtime·osinit(<span class="built_in">SB</span>)</span><br><span class="line"><span class="symbol">CALL</span>runtime·schedinit(<span class="built_in">SB</span>)</span><br><span class="line"></span><br><span class="line">// create a new goroutine to start program</span><br><span class="line"><span class="keyword">MOVQ</span>$runtime·mainPC(<span class="built_in">SB</span>), AX// <span class="meta">entry</span></span><br><span class="line"><span class="keyword">PUSHQ</span>AX</span><br><span class="line"><span class="keyword">PUSHQ</span><span class="number">$0</span>// arg size</span><br><span class="line"><span class="symbol">CALL</span>runtime·newproc(<span class="built_in">SB</span>)</span><br><span class="line"><span class="keyword">POPQ</span>AX</span><br><span class="line"><span class="keyword">POPQ</span>AX</span><br><span class="line"></span><br><span class="line">// start this M</span><br><span class="line"><span class="symbol">CALL</span>runtime·mstart(<span class="built_in">SB</span>)</span><br><span class="line"></span><br><span class="line"><span class="symbol">CALL</span>runtime·abort(<span class="built_in">SB</span>)// mstart should never return</span><br><span class="line"><span class="symbol">RET</span></span><br></pre></td></tr></table></figure><h3 id="runtime-osinit"><a href="#runtime-osinit" class="headerlink" title="runtime.osinit"></a>runtime.osinit</h3><blockquote><p>根据 OS 不同，在不同的文件中：src/runtime/os_*.go</p></blockquote><p>获取 cpu 的核数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">osinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">ncpu = getproccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime·schedinit"><a href="#runtime·schedinit" class="headerlink" title="runtime·schedinit"></a>runtime·schedinit</h3><blockquote><p>src/runtime/proc.go</p></blockquote><p>schedt 结构初始化:</p><ol><li>设置 M 的最大数量为 10000</li><li>stack、args、envs、gc 等初始化</li><li>P 数量初始化；此时 STW，sched 上锁，生成的 P 会被放入 <code>schedt.pidle</code> 中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// M 最多为10000个</span></span><br><span class="line">sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 CPU 核数、GOMAXPROCS调整 procs</span></span><br><span class="line">procs := ncpu</span><br><span class="line"><span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">procs = n</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据 procs 调整 P 的数量</span></span><br><span class="line"><span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime·newproc"><a href="#runtime·newproc" class="headerlink" title="runtime·newproc"></a>runtime·newproc</h3><blockquote><p>src/runtime/proc.go</p></blockquote><p>创建一个 G</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(size <span class="keyword">int32</span>,fn *funcval)</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp *<span class="keyword">uint8</span>, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 gFree 中获取 G；若本地为空，则从全局拿32个放入本地</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 G 放入到 p.runnext，若本地队列满了(&gt;256),则从本地队列拿一半+当前 G 放入全局队列)</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 若有空闲 P， M0 已启动，并且没有自旋 M（启动过程中不会执行）</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &amp;&amp; mainStarted &#123;</span><br><span class="line"><span class="comment">// 尝试再添加一个 P 来执行 G</span></span><br><span class="line">wakep()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引导过程中不会执行以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wakep</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 获取一个空闲 P，M；并绑定</span></span><br><span class="line">startm(<span class="literal">nil</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">  <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 从 schedt.pidle 中获取空闲的 P</span></span><br><span class="line">_p_ = pidleget()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 从 schedt.midle 中获取空闲的 M</span></span><br><span class="line">mp := mget()</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line"><span class="keyword">if</span> mp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 创建新的 M（ OS thread）</span></span><br><span class="line">newm(fn, _p_)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runtime·mstart"><a href="#runtime·mstart" class="headerlink" title="runtime·mstart"></a>runtime·mstart</h3><blockquote><p>src/runtime/proc.go</p></blockquote><p>找到一个 P，并绑定一个 M，然后执行 G<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 获取当前 G</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mstart1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 获取当前 G</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 M0</span></span><br><span class="line"><span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">mstartm0()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line"><span class="comment">// 关联 P 和 M</span></span><br><span class="line">acquirep(_g_.m.nextp.ptr())</span><br><span class="line">_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到一个可执行的 G，并执行</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span>&#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// // ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 1/61 的几率从全局取 G，调用 rungput 放入本地队列</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;sched.lock)</span><br><span class="line">gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 从本地队列取 G</span></span><br><span class="line">gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line"><span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 循环：本地队列 -&gt; 全局队列 -&gt; poll network -&gt; 偷其他 P 一半 G -&gt; 检查 P -&gt; GC</span></span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是自旋 M, 则停止当前 M，然后调用 wakep 开启新的自旋 M</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">resetspinning()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 G，从 G0 -&gt; G</span></span><br><span class="line">execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">g := getg()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">1000000000</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxstacksize = <span class="number">250000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">    <span class="comment">// 开启 sysmon 监控线程，若 P 处于 syscall，则获取一个 M 拿走 P 下的 G</span></span><br><span class="line">systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行用户的 init()</span></span><br><span class="line">fn := main_init <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 main.main()</span></span><br><span class="line">fn = main_main <span class="comment">// make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们学习一个新事物时，一定要做到「知其然知其所以然」。最近看了一些 go 的源码，对 go 的设计有了更深的认识，也让自己在工作中使用的更得心应手。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://www.helongfei.com/categories/go/"/>
    
    
      <category term="go" scheme="http://www.helongfei.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go 并发原理 - 调度篇</title>
    <link href="http://www.helongfei.com/2019/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86-%E8%B0%83%E5%BA%A6%E7%AF%87/"/>
    <id>http://www.helongfei.com/2019/go并发原理-调度篇/</id>
    <published>2019-07-14T02:02:00.000Z</published>
    <updated>2019-07-14T18:33:43.566Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>众所周知，<code>Goroutine</code> 是 Go 最小的执行单位，作为开发者，我们在使用「廉价」的 <code>Goroutine</code> 的时候，有没有想过背后的实现原理？有没有因为「滥用」<code>Goroutine</code> ，而踩过坑？我们今天来简要分析下 Go 的并发原理。</p><a id="more"></a><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p>在讲解 <code>Go Scheduler</code> 之前，我们先来了解下目前主流的线程模型；按照用户线程和内核线程之间的关系，可以分为以下三种：</p><h3 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h3><blockquote><p>用户线程：内核线程 = 1：1</p></blockquote><p><img src="/images/2019/06/thread2.png" alt="thread2"><br>每个用户线程绑定一个内核线程，调度由「内核」完成；</p><p>优点：实现简单（直接调用「系统调用」），可以并行（利用多核）<br>缺点：占用资源多，上下文切换慢</p><h3 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h3><blockquote><p>用户线程：内核线程 = N：1</p></blockquote><p><img src="/images/2019/06/thread1.png" alt="thread1"><br>多个用户线程(从属于单个进程)绑定一个内核线程，调度由「用户」完成；也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程；许多语言的「协程库」都属于这种方式。</p><p>优点：占用资源少，上下文切换快，性能优于「内核级线程模型」<br>缺点：不支持多核，原生不支持并发（单个用户线程有阻塞调用，则所有线程都阻塞；因为此模式下操作系统的调度最小单位为进程）</p><p>可以通过封装阻塞调用为非阻塞调用，来避免所有线程都阻塞。</p><h3 id="两级-混合型-线程模型"><a href="#两级-混合型-线程模型" class="headerlink" title="两级(混合型)线程模型"></a>两级(混合型)线程模型</h3><blockquote><p>用户线程：内核线程 = M：N</p></blockquote><p>一个用户进程（包含多个线程）可以「动态绑定」多个内核线程；调度由「内核、用户」完成（用户调度器实现用户线程到内核线程的调度，内核调度器实现内核线程到CPU上的调度）；比如：某个内核线程由于其绑定的用户线程阻塞了，这个内核线程关联的其他用户线程可以重新绑定其他内核线程。</p><p>优点：支持并发，占用资源少<br>缺点：调度复杂</p><p>Go 采用的是此线程模型。</p><h2 id="CSP-并发模型"><a href="#CSP-并发模型" class="headerlink" title="CSP 并发模型"></a>CSP 并发模型</h2><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating</p></blockquote><p>CSP 最早是由 Tony Hoare 在 1977 年提出，严格来说，CSP 是一门形式语言，用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了 Occam/Limbo/Golang…</p><blockquote><p><a href="http://www.usingcsp.com/cspbook.pdf" rel="external nofollow noopener noreferrer" target="_blank">《Communicating Sequential Processes》</a></p></blockquote><p>不同于传统的多线程通过「共享内存」来通信，CSP 提倡「以通信的方式来共享内存」。</p><p>Go 其实只用到了 CSP 的很小一部分，即理论中的 Process/Channel（对应到 Go 中的 goroutine/channel）：这两个并发原语之间相互独立，Process 通过对 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p><h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><blockquote><p>本质上，操作系统运行线程，线程运行你的代码。</p></blockquote><p>Go 编译器会在 Go 运行时的一些地方插入系统调用，（比如通过 channel 发送值,调用 runtime 包等），所以 Go 可以通知调度器执行特定的操作。</p><p><img src="/images/2019/07/go-runtime.png" alt="go-runtime"></p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>在 Golang 中，任何代码都是运行在 goroutine 里，即便没有显式的 <code>go func()</code> ，默认的 main 函数也是一个 goroutine。</p><ol><li>Goroutine 不是协程；Go 使用的是两级线程模型</li><li>Goroutine 开销很小；它有自己的栈，不同于内核线程固定大小的内存块(2MB)，goroutine 的栈初始值是 2KB，可以动态增长到 1G（64位1G，32位256M），GC 还会周期性回收不再使用的内存，收缩栈空间）</li></ol><h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><blockquote><p><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw" rel="external nofollow noopener noreferrer" target="_blank">《Go Scheduler 设计文档》</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Go scheduler 内部有三个重要的结构：M、P、G</p><ul><li>M：OS 线程</li><li>P：Go 代码执行所需要的资源</li><li>G：Goroutine</li></ul><p><img src="/images/2019/06/mpg.png" alt="MPG"></p><p>在 Go 1.0 的时候，它的调度器是 MG 模型，有以下几个问题：</p><ol><li>全局锁 (每个 Goroutine 的操作都要上锁)</li><li>M 直接和 G 交互，导致调度延迟、性能损耗（OS 调度）</li><li>每个 M 都有自己的 cache，导致内存占用过高</li><li>系统调用形成的阻塞，导致性能呢损耗</li></ol><p>为了解决以上几个问题，在 Go 1.1 的时候，引入了 P，并实现了 <a href="http://supertech.csail.mit.edu/papers/steal.pdf" rel="external nofollow noopener noreferrer" target="_blank">work stealing</a> 调度算法，演进为现在的 MPG 模型。</p><h3 id="MPG-模型"><a href="#MPG-模型" class="headerlink" title="MPG 模型"></a>MPG 模型</h3><p><img src="/images/2019/06/go-scheduler2.png" alt="Go scheduler2"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/" rel="external nofollow noopener noreferrer" target="_blank">Scalable Go Scheduler Design Doc</a></li><li><a href="https://segmentfault.com/a/1190000015464889" rel="external nofollow noopener noreferrer" target="_blank">Goroutine并发调度模型深度解析之手撸一个协程池</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIyMTg0OTExOQ==&amp;mid=2247484436&amp;idx=2&amp;sn=2864adc11a787c1c3ee79e8dbd96c27a&amp;chksm=e8373764df40be72df5a6240998b19ab0ff45ac9a53a9e5c6b7ed0d7eabedd5a8098db9d87c2&amp;mpshare=1&amp;scene=1&amp;srcid=07272kBJCM3KUJy3tfps1FdM%23rd" rel="external nofollow noopener noreferrer" target="_blank">Go并发原理-贝壳</a></li><li><a href="https://colobu.com/2017/05/04/go-scheduler/" rel="external nofollow noopener noreferrer" target="_blank">Go 调度器: M, P 和 G</a></li><li><a href="https://speakerdeck.com/retervision/go-runtime-scheduler" rel="external nofollow noopener noreferrer" target="_blank">Go Runtime Scheduler</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，&lt;code&gt;Goroutine&lt;/code&gt; 是 Go 最小的执行单位，作为开发者，我们在使用「廉价」的 &lt;code&gt;Goroutine&lt;/code&gt; 的时候，有没有想过背后的实现原理？有没有因为「滥用」&lt;code&gt;Goroutine&lt;/code&gt; ，而踩过坑？我们今天来简要分析下 Go 的并发原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Go runtime" scheme="http://www.helongfei.com/categories/Go-runtime/"/>
    
    
      <category term="go" scheme="http://www.helongfei.com/tags/go/"/>
    
      <category term="runtime" scheme="http://www.helongfei.com/tags/runtime/"/>
    
      <category term="scheduler" scheme="http://www.helongfei.com/tags/scheduler/"/>
    
  </entry>
  
  <entry>
    <title>Go 并发编程-应用篇</title>
    <link href="http://www.helongfei.com/2019/go-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%BA%94%E7%94%A8%E7%AF%87/"/>
    <id>http://www.helongfei.com/2019/go-并发编程-应用篇/</id>
    <published>2019-07-11T17:16:00.000Z</published>
    <updated>2019-07-13T09:07:19.290Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>当提到并发编程的时候，人们往往会想到多线程，而 Go 最被人熟知的是借鉴 CSP 的 gorountine &amp; channel 并发模式，那 Go 中是否支持类似传统多线程的并发编程方式呢？答案是支持；因为 Go 的 Sync 包给我们提供了互斥锁、原子操作、条件变量等同步原语。</p><a id="more"></a><p>本文主要介绍下同步原语的用法，并发下的数据存储，以及 Goroutine 的使用方式和注意事项。</p><h1 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h1><h2 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h2><blockquote><p>互斥锁，1.9 引入「饥饿模式」解决了尾延时（队列头的 Goroutine 会被新建 Goroutine 抢占锁）</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler something</span></span><br><span class="line"></span><br><span class="line">s.Unlock()</span><br></pre></td></tr></table></figure><h2 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h2><blockquote><p> 读写互斥锁，用于并发读</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.RWMutex</span><br><span class="line"></span><br><span class="line">s.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler something</span></span><br><span class="line"></span><br><span class="line">s.RUnlock()</span><br></pre></td></tr></table></figure><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><blockquote><p>只执行一次；即使执行的是不同的 func，也只会执行一次。</p></blockquote><p>Once 只有一个 Do 方法，参数是函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s sync.Once</span><br><span class="line"></span><br><span class="line">onceFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"once"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onceFunc2 := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"once"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会输出一个 once</span></span><br><span class="line">s.Do(onceFunc)</span><br><span class="line">s.Do(onceFunc2)</span><br></pre></td></tr></table></figure><h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><blockquote><p>原子操作</p></blockquote><p>sync/atomic 提供了针对整型、通用类型的原子操作。</p><p>针对整型的方法有：加(Add)、CAS(交换并比较 compare and swap)、存储(store)、读取(load)以及交换(swap)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 还支持 uint32、int64 等</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">atomic.AddInt32(&amp;i, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 不会改变 i 的值</span></span><br><span class="line">atomic.CompareAndSwapInt32(&amp;i, <span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 会改变 i 的值</span></span><br><span class="line">atomic.CompareAndSwapInt32(&amp;i, <span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line"><span class="comment">// 交换值，并返回旧值的指针</span></span><br><span class="line">atomic.SwapInt32(&amp;i, <span class="number">-1</span>)</span><br><span class="line">fmt.Println(atomic.LoadInt32(&amp;i))</span><br><span class="line"><span class="comment">// 存储值</span></span><br><span class="line">atomic.StoreInt32(&amp;i, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>针对通用类型的方法有：Store 存储、Load 读取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> atomicVal atomic.Value</span><br><span class="line"></span><br><span class="line">str := <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储</span></span><br><span class="line">atomicVal.Store(str)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">fmt.Println(atomicVal.Load())</span><br></pre></td></tr></table></figure><h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><blockquote><p>让 Goroutine 在某个条件下被阻塞/唤醒</p></blockquote><p>Cond 提供三个方法：Wait 阻塞、Signal 唤醒、Broadcast 唤醒所有 Goroutine；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化需要一个锁</span></span><br><span class="line">c := sync.NewCond(&amp;sync.Mutex&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> listen(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> broadcast(c)</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, os.Interrupt)</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listen</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Wait() <span class="comment">// 阻塞；以下代码暂不执行</span></span><br><span class="line">fmt.Println(<span class="string">"listen"</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">broadcast</span><span class="params">(c *sync.Cond)</span></span> &#123;</span><br><span class="line">c.L.Lock()</span><br><span class="line">c.Broadcast() <span class="comment">// 唤醒所有的 Goroutine</span></span><br><span class="line">fmt.Println(<span class="string">"release"</span>)</span><br><span class="line">c.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Singal 会唤醒阻塞时间最长的 Goroutine。</p><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><blockquote><p>最常用的同步机制，多用于等待一批 Goroutine 的返回</p></blockquote><p>WaitGroup 提供三个方法：Add 计数、Done 完成（计数-1）、Wait 阻塞到计数为0为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"handler something"</span>)</span><br><span class="line">  &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>1.9 引入的并发安全 sync.map（1.9 之前的 map 在不加锁的前提下进行写操作会报错）</p></blockquote><p>Map 提供五个方法：Store 存储键值对、LoadOrStore 读取或存储键值对、Load 读取键值对、Delete 删除键值对、Range 遍历键值对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line">m.Store(<span class="string">"k"</span>, <span class="string">"v"</span>)</span><br><span class="line">m.Load(<span class="string">"k"</span>)</span><br><span class="line"><span class="comment">// 不会覆盖 k 的值</span></span><br><span class="line">m.LoadOrStore(<span class="string">"k"</span>, <span class="string">"v1"</span>)</span><br><span class="line"><span class="comment">// 会覆盖 k 的值</span></span><br><span class="line">m.Store(<span class="string">"k"</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">"k1"</span>: <span class="string">"v1"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  fmt.Println(key, value)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><blockquote><p>并发安全，用于存储可复用的临时对象，以减少垃圾回收的压力</p></blockquote><p>Pool 提供了两个方法：Get 获取对象，Put 放入对象</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个[]byte的对象池，每个对象为一个[]byte</span></span><br><span class="line"><span class="keyword">var</span> bytePool = sync.Pool&#123;</span><br><span class="line">  <span class="comment">// 获取对象不存在时则创建</span></span><br><span class="line">  New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;b</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取对象</span></span><br><span class="line">obj := bytePool.Get().(*[]<span class="keyword">byte</span>)</span><br><span class="line">_ = obj</span><br><span class="line"><span class="comment">// 对象放入池子</span></span><br><span class="line">bytePool.Put(obj)</span><br></pre></td></tr></table></figure><h1 id="上下文-Context"><a href="#上下文-Context" class="headerlink" title="上下文 Context"></a>上下文 Context</h1><p>当我们在 Goroutine 中再次产生一个 Goroutine 的时候，若前者异常退出，理论上后者也应该退出，否则就是对资源的浪费。</p><p><strong>Context 的主要作用就是在不同的 Goroutine 之间同步请求特定的数据、取消信号以及处理请求的截止日期。</strong></p><p>可以把 Context 类比为一棵树结构：</p><ul><li><p>根节点不可取消；那生成根节点的方法有：context.Background()、context.TODO()；两者的区别是没有本质区别，当不知道使用什么的时候用 TODO()；常用的是 Background()。</p></li><li><p>生成子节点的方法有：WithCancel 手动取消、WithDeadline 定时取消、WithTImeout 定时取消、WithValue 存键值对</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 手动取消</span></span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时取消 - 截止</span></span><br><span class="line">d := time.Now().Add(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">ctx, cancel := context.WithDeadline(context.Background(), d)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时取消 - 超时</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">50</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存键值对(先找子节点再找父节点)</span></span><br><span class="line">ctx := context.WithValue(context.Background(), <span class="string">"kkk"</span>, <span class="string">"vvv"</span>)</span><br><span class="line">fmt.Println(ctx.Value(<span class="string">"kkk"</span>))</span><br></pre></td></tr></table></figure><p>键值对不要存过多的参数，一般常用来存储 global trace id。</p><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Channel 分为有 buffer channel 、无 buffer channel；若是无 buffer 的 channel，在一端没有准备好数据之前，另一端会阻塞；若是有 buffer 的 channel，则 buffer 未满之前是不阻塞的。</p><p>使用起来比较简单；提供四个方法：</p><ol><li>创建 channel</li><li>数据写入 channel</li><li>读取 channel 数据</li><li>关闭 channel（无法写入数据，但可以读取）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 无缓存</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 有缓存</span></span><br><span class="line"><span class="comment">//ch1 := make(chan int,10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="keyword">go</span> receive(ch1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">send(ch1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 channel</span></span><br><span class="line"><span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">d := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">"one"</span>, d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> d := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(<span class="string">"two"</span>, d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 还支持只读、只写操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> receive(ch)</span><br><span class="line">send(ch)</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receive</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 只写里可以执行关闭 channel 的操作</span></span><br><span class="line">  <span class="comment">// close(ch)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li><p>信号传递<br>把数据当做信号放入 channel；一般使用无 buffer 的 channel；常和 WaitGroup 配合控制并发数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"handler something"</span>)</span><br><span class="line"><span class="comment">// 通知 main goroutine 任务处理完毕</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞；等待新建 goroutine 中处理任务</span></span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息队列<br>把数据放入 channel 等待消费；一般使用有 buffer 的 channel。</p></li><li><p>多个 channel 串联为 Pipeline<br>每个 channel 的输出当做另一个 channel 的输入。<br><img src="/images/2019/07/pipeline.png" alt="pipeline"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数</span></span><br><span class="line"><span class="keyword">go</span> counter(ch1)</span><br><span class="line"><span class="comment">// 平方</span></span><br><span class="line"><span class="keyword">go</span> square(ch1, ch2)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">go</span> output(ch2)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">ch1 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="keyword">int</span>, ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">i *= i</span><br><span class="line">ch2 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">output</span><span class="params">(ch2 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch2 &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>多路复用；语法类似 Switch，有 default 则不阻塞，无 default 则：</p><ul><li>条件都未成立，则阻塞</li><li>条件分支某个成立，则执行</li><li>条件分支都成立，则随机选择一个</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> d1 := &lt;-ch1:</span><br><span class="line">    fmt.Println(d1)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second): <span class="comment">// 设置超时时间</span></span><br><span class="line">    fmt.Println(<span class="string">"timeout"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Goroutine-泄露"><a href="#Goroutine-泄露" class="headerlink" title="Goroutine 泄露"></a>Goroutine 泄露</h2><p>Goroutine 的开销很小，但若是使用不当，造成 GC 无法回收的话，久而久之就会引起内存耗尽。</p><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ol><li><p>nil channel</p><p> 永远阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> nilChannel(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nilChannel</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有接收者的 channel</p><p>例：并发请求两个搜索引擎，响应结果写入 channel；我们使用最先收到的响应，丢失之后的响应，这样会造成后者 goroutine 一直阻塞<br>解决方案：保证 channel 里的数据都会被读取，或者使用 context 取消其他请求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 查询结果</span></span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">go</span> baidu(ch)</span><br><span class="line"> <span class="keyword">go</span> bing(ch)</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输出查询结果</span></span><br><span class="line"> <span class="keyword">go</span> res(ch)</span><br><span class="line"></span><br><span class="line"> time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">baidu</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"> res, _ := http.Get(<span class="string">"https://baidu.com"</span>)</span><br><span class="line"> ch &lt;- res.StatusCode + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">bing</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"> res, _ := http.Get(<span class="string">"https://cn.bing.com"</span>)</span><br><span class="line"> ch &lt;- res.StatusCode + <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">res</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"> code := &lt;-ch</span><br><span class="line"> fmt.Println(code, runtime.NumGoroutine())</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>没有接收者的 channel</p></li><li>程序死循环</li></ol><p>由此可以看出，goroutine 泄露都是因为使用不当造成的；所以我们在使用 goroutine 的时候一定要小心。</p><h2 id="泄露检测"><a href="#泄露检测" class="headerlink" title="泄露检测"></a>泄露检测</h2><ol><li><p>观察 runtime.NumGoroutine</p></li><li><p>pprof</p><ol><li><p>通过 web 查看</p><blockquote><p>net/http/pprof</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    _ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">log.Println(http.ListenAndServe(<span class="string">"localhost:6060"</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:6060/debug/pprof/goroutine?debug=1" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:6060/debug/pprof/goroutine?debug=1</a> 查看 gorutine 状态</p></li><li><p>通过 stdout 查看</p><blockquote><p>runtime/pprof</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"runtime/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">pprof.Lookup(<span class="string">"goroutine"</span>).WriteTo(os.Stdout, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>gops</p><blockquote><p><a href="https://github.com/google/gops" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/google/gops</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/google/gops/agent"</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := agent.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Hour)</span><br></pre></td></tr></table></figure></li><li><p>leaktest</p><blockquote><p><a href="https://github.com/fortytw2/leaktest" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fortytw2/leaktest</a></p></blockquote><p>基本原理：在测试的开始和结束的时候，利用 runtime.Stack 获取活跃 goroutine 的堆栈跟踪。如果在测试完成后还有一些新的 goroutine，那么将其归类为泄露。</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://draveness.me/golang/concurrency/golang-sync-primitives.html" rel="external nofollow noopener noreferrer" target="_blank">同步原语与锁</a></li><li><a href="https://juejin.im/post/5c1dce2d51882508506061f2#heading-10" rel="external nofollow noopener noreferrer" target="_blank">Golang非CSP并发模型外的其他并行方法总结</a></li><li><a href="https://studygolang.com/articles/12495" rel="external nofollow noopener noreferrer" target="_blank">Goroutine 泄露</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当提到并发编程的时候，人们往往会想到多线程，而 Go 最被人熟知的是借鉴 CSP 的 gorountine &amp;amp; channel 并发模式，那 Go 中是否支持类似传统多线程的并发编程方式呢？答案是支持；因为 Go 的 Sync 包给我们提供了互斥锁、原子操作、条件变量等同步原语。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://www.helongfei.com/categories/go/"/>
    
    
      <category term="go" scheme="http://www.helongfei.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenResty 实现 Grafana 免登录</title>
    <link href="http://www.helongfei.com/2019/%E4%BD%BF%E7%94%A8-openresty-%E5%AE%9E%E7%8E%B0-grafana-%E5%85%8D%E7%99%BB%E5%BD%95/"/>
    <id>http://www.helongfei.com/2019/使用-openresty-实现-grafana-免登录/</id>
    <published>2019-06-20T10:44:00.000Z</published>
    <updated>2019-07-14T08:34:01.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司内部都有管理后台，一般都会把第三方软件集成到后台，收敛登录入口。 本文主要介绍一种集成 Grafana 的方法。<br><a id="more"></a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>假设，只有一个 <code>token</code> ，通过这个 <code>token</code> 可以获取到用户信息，在这种情况下，怎么可以免登录进入 <code>Grafana</code>？</p><p>例：访问：<a href="http://grafana.com?token=xxxxxxx" rel="external nofollow noopener noreferrer" target="_blank">http://grafana.com?token=xxxxxxx</a> 后，不应该跳转到 <a href="http://grafana.com/login" rel="external nofollow noopener noreferrer" target="_blank">http://grafana.com/login</a> ，而应该直接进入 <a href="http://grafana.com/home" rel="external nofollow noopener noreferrer" target="_blank">http://grafana.com/home</a></p><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>通过查看<a href="https://grafana.com/docs/auth/overview/" rel="external nofollow noopener noreferrer" target="_blank">文档</a>，可以发现 <code>Grafana</code> 支持多种权限认证；但没有一个能完美解决我们问题的方案；唯一比较接近的是 <code>Auth Proxy</code>，说是可以在 <code>Grafana</code> 外部进行权限验证，经过通读文档和试验，发现其本质是：通过 web server 校验后，在每个请求上增加一个 header (默认 <code>X-WEBAUTH-USER</code>)来实现免登录；文档中的示例是通过 <code>htpasswd</code> 来实现的权限验证，那自然想到可以通过 <code>OpenResty</code> 进行权限校验。</p><p>假设 token 对应的用户信息存在 Redis 中，基本流程如下：<br><img src="/images/2019/06/grafana-login.png" alt="grafana_login"></p><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h2 id="Auth-Proxy"><a href="#Auth-Proxy" class="headerlink" title="Auth Proxy"></a>Auth Proxy</h2><p>本质是增加一个<code>header</code>（默认 <code>X-WEBAUTH-USER</code>）；</p><p><code>Grafana</code> 开启<code>Auth Proxy</code>；配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[auth.proxy]</span></span><br><span class="line"><span class="attr">enabled</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">; defalut header name</span></span><br><span class="line"><span class="attr">header_name</span> = X-WEBAUTH-USER</span><br><span class="line"><span class="comment">; username or email</span></span><br><span class="line"><span class="attr">header_property</span> = username</span><br><span class="line"><span class="comment">; 自动注册</span></span><br><span class="line"><span class="attr">auto_sign_up</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">; 白名单</span></span><br><span class="line"><span class="attr">whitelist</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure></p><h2 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h2><p><code>OpenResty</code>的配置为：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">  <span class="attribute">server_name</span> grafana.com;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">content_by_lua_file</span> <span class="string">"/usr/local/etc/openresty/conf.d/grafana.lua"</span>;</span><br><span class="line">    <span class="comment"># 本质是为了加这个 header</span></span><br><span class="line">    <span class="comment"># proxy_set_header X-WEBAUTH-USER "longfeihe";</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">location</span> <span class="variable">@grafana</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 若使用 url 接口鉴权，则开启此 location</span></span><br><span class="line">  <span class="comment">#location ^~ /proxy/ &#123;</span></span><br><span class="line">  <span class="comment">#  internal; # 内部请求</span></span><br><span class="line">  <span class="comment">#  proxy_pass http://someone-proxy.com/; # 必须有 /</span></span><br><span class="line">  <span class="comment">#  proxy_set_header Accept "*/*";</span></span><br><span class="line">  <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>grafana.lua</code><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config redis start</span></span><br><span class="line"><span class="keyword">local</span> redisIp = <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="keyword">local</span> redisPort = <span class="string">'6379'</span></span><br><span class="line"><span class="comment">-- config redis end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">"cjson"</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span></span><br><span class="line"><span class="keyword">local</span> aes = <span class="built_in">require</span> <span class="string">"resty.aes"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getToken</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> args = ngx.req.get_uri_args()</span><br><span class="line">    <span class="keyword">local</span> token = args[<span class="string">'token'</span>]</span><br><span class="line">    <span class="keyword">return</span> token</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conRedis</span><span class="params">(ip, port)</span></span></span><br><span class="line">    <span class="keyword">local</span> red = redis.new()</span><br><span class="line">    <span class="keyword">local</span> ok, err = red:connect(ip, port)</span><br><span class="line">    red:set_timeout(<span class="number">1000</span>) <span class="comment">-- 1s</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">'connect redis fail'</span>)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(ngx.HTTP_SERVICE_UNAVAILABLE)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">'connect redis success'</span>)</span><br><span class="line">    <span class="keyword">return</span> red</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsernameByRedis</span><span class="params">(token)</span></span></span><br><span class="line">    <span class="keyword">local</span> red = conRedis(redisIp, redisPort)</span><br><span class="line">    token = ngx.md5(token .. <span class="string">'_sso'</span>)</span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">'fetch redis key:'</span> .. token)</span><br><span class="line">    <span class="keyword">local</span> value = red:get(token)</span><br><span class="line">    closeRedis(red)</span><br><span class="line">    <span class="keyword">if</span> value ~= ngx.null <span class="keyword">then</span></span><br><span class="line">        obj = cjson.decode(value)</span><br><span class="line">        <span class="keyword">local</span> username = obj[<span class="string">'username'</span>]</span><br><span class="line">        <span class="keyword">return</span> username</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 url 鉴权</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsernameByUrl</span><span class="params">(token)</span></span></span><br><span class="line">    <span class="keyword">local</span> uri = <span class="string">"/proxy/get-user-info"</span> <span class="comment">-- 这里接口地址按实际情况进行修改</span></span><br><span class="line">    <span class="comment">--ngx.req.set_header("X-TOKEN", token)</span></span><br><span class="line">    res = ngx.location.capture(uri, &#123;</span><br><span class="line">        method = ngx.HTTP_POST</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> res.body <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> data = cjson.decode(res.body)</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">"code"</span>] ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"request model for get user info was failed; msg:"</span> .. data[<span class="string">"message"</span>])</span><br><span class="line">            ngx.<span class="built_in">exit</span>(ngx.HTTP_BAD_GATEWAY)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">local</span> email = data[<span class="string">"data"</span>][<span class="string">"email"</span>]</span><br><span class="line">        <span class="keyword">return</span> email</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"request model for get user info was failed; code:"</span> .. res.<span class="built_in">status</span>)</span><br><span class="line">        ngx.<span class="built_in">exit</span>(ngx.HTTP_BAD_GATEWAY)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeRedis</span><span class="params">(redis)</span></span></span><br><span class="line">    <span class="keyword">local</span> ok, err = redis:<span class="built_in">close</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">'close redis connect fail'</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">'close redis connect success'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setHeader</span><span class="params">(username)</span></span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">'X-WEBAUTH-USER:'</span> .. username)</span><br><span class="line">    ngx.req.set_header(<span class="string">"X-WEBAUTH-USER"</span>, username)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">setCookie</span><span class="params">(username)</span></span></span><br><span class="line">    ngx.header[<span class="string">'Set-Cookie'</span>] = &#123; <span class="string">'token='</span> .. encrypt(username) &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">getUsernameByCookie</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> token = ngx.var.cookie_token</span><br><span class="line">    <span class="keyword">return</span> decrypt(token)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">logout</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">if</span> ngx.re.<span class="built_in">match</span>(ngx.var.request_uri, <span class="string">"logout"</span>) <span class="keyword">then</span></span><br><span class="line">        ngx.header[<span class="string">'Set-Cookie'</span>] = &#123; <span class="string">'token='</span> &#125;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span><span class="params">(encryptString)</span></span></span><br><span class="line">    <span class="keyword">local</span> aes_128_cbc_md5 = aes:new(<span class="string">"AKeyForAES"</span>)</span><br><span class="line">    <span class="keyword">return</span> ngx.encode_base64(aes_128_cbc_md5:encrypt(encryptString))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span><span class="params">(decryptString)</span></span></span><br><span class="line">    <span class="keyword">local</span> aes_128_cbc_md5 = aes:new(<span class="string">"AKeyForAES"</span>)</span><br><span class="line">    <span class="keyword">local</span> decrypt = ngx.decode_base64(decryptString)</span><br><span class="line">    <span class="keyword">return</span> aes_128_cbc_md5:decrypt(decrypt)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- main</span></span><br><span class="line">logout()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> token = getToken()</span><br><span class="line"><span class="keyword">if</span> token <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.INFO, <span class="string">'get token:'</span> .. token)</span><br><span class="line">    <span class="keyword">local</span> username = getUsernameByRedis(token)</span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">then</span></span><br><span class="line">        setHeader(username)</span><br><span class="line">        setCookie(username)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ngx.exec(<span class="string">"@grafana"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">local</span> username = getUsernameByCookie()</span><br><span class="line">    <span class="keyword">if</span> username <span class="keyword">then</span></span><br><span class="line">        setHeader(username)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ngx.exec(<span class="string">"@grafana"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://grafana.com/docs/auth/auth-proxy/" rel="external nofollow noopener noreferrer" target="_blank">Auth Proxy Authentication</a></li><li><a href="http://openresty.org/en/" rel="external nofollow noopener noreferrer" target="_blank">OpenResty</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;公司内部都有管理后台，一般都会把第三方软件集成到后台，收敛登录入口。 本文主要介绍一种集成 Grafana 的方法。&lt;br&gt;
    
    </summary>
    
      <category term="监控" scheme="http://www.helongfei.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="grafana" scheme="http://www.helongfei.com/tags/grafana/"/>
    
      <category term="openresty" scheme="http://www.helongfei.com/tags/openresty/"/>
    
      <category term="lua" scheme="http://www.helongfei.com/tags/lua/"/>
    
  </entry>
  
  <entry>
    <title>Open-Falcon 浅析</title>
    <link href="http://www.helongfei.com/2019/open-falcon-%E6%B5%85%E6%9E%90/"/>
    <id>http://www.helongfei.com/2019/open-falcon-浅析/</id>
    <published>2019-06-11T15:44:00.000Z</published>
    <updated>2019-07-02T10:26:55.109Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="监控系统概述"><a href="#监控系统概述" class="headerlink" title="监控系统概述"></a>监控系统概述</h1><p>在监控系统领域，相信大家都经历过 Zabbix 的时代；在公司刚起步，机器数量不多时，Zabbix 可以很好的满足我们的需求，但是随着业务的发展，Zabbix 的存储会成为主要的性能瓶颈，从而引发很多问题，增加运维成本。</p><p>近些年来，随着互联网技术的不断发展，技术架构的不断演进，监控领域有两个我值得推荐的开源系统：一个是小米出品的 Open-Falcon，一个是基于 Google Borgmon 的开源实现 Prometheus。</p><p>今天主要介绍下 Open-Falcon。<br><a id="more"></a></p><p>Open-Falcon 有如下特点：</p><ol><li><strong>强大灵活的数据采集</strong>：自动发现，支持falcon-agent、snmp、支持用户主动push、用户自定义插件支持、opentsdb data model like（timestamp、endpoint、metric、key-value tags）</li><li><strong>水平扩展能力</strong>：支持每个周期上亿次的数据采集、告警判定、历史数据存储和查询</li><li><strong>高效率的告警策略管理</strong>：高效的portal、支持策略模板、模板继承和覆盖、多种告警方式、支持callback调用</li><li><strong>人性化的告警设置</strong>：最大告警次数、告警级别、告警恢复通知、告警暂停、不同时段不同阈值、支持维护周期</li><li><strong>高效率的graph组件</strong>：单机支撑200万metric的上报、归档、存储（周期为1分钟）</li><li><strong>高效的历史数据query组件</strong>：采用rrdtool的数据归档策略，秒级返回上百个metric一年的历史数据</li><li><strong>dashboard</strong>：多维度的数据展示，用户自定义Screen</li><li><strong>高可用</strong>：整个系统无核心单点，易运维，易部署，可水平扩展</li><li><strong>开发语言</strong>： 整个系统的后端，全部golang编写，portal和dashboard使用python编写。</li></ol><p>简而言之：Open-falcon 是一个模块化、高可用、高性能、支持水平扩展的监控告警系统，支持机器监控、业务监控、各种开源软件的监控。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p><img src="/images/2019/06/architecture.png" alt="Architecture"></p><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><blockquote><p>数据采集组件</p></blockquote><p>部署在业务机器上，主要作用：</p><ol><li>自动采集预先定义的各种采集项（机器级别的监控指标）</li><li>agent 还提供一个 HTTP 接口（/v1/push），用于接收用户自定义上报数据</li></ol><p>每隔60秒，通过 JsonRPC push 数据到 Transfer 模块（使用长连接）。</p><h2 id="Transfer"><a href="#Transfer" class="headerlink" title="Transfer"></a>Transfer</h2><blockquote><p>数据转发服务</p></blockquote><p>主要作用：</p><ol><li>接收 agent 上报的数据</li><li>按照哈希规则进行数据分片，并将分片后的数据分别 push 给 graph、judge 等组件</li></ol><h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><blockquote><p>存储绘图数据、历史数据</p></blockquote><p>主要作用：</p><ol><li>接口 transfer 推送数据</li><li>处理 API 组件的查询请求、返回绘图数据</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p>绘图数据的查询接口</p></blockquote><p>主要作用：根据一致性哈希算法去相应的 graph 实例查询不同监控项的数据，汇总后返回</p><h2 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h2><blockquote><p>面向用户的查询界面</p></blockquote><h2 id="Judge"><a href="#Judge" class="headerlink" title="Judge"></a>Judge</h2><blockquote><p>告警判断</p></blockquote><p>因为数据量太大，此组件放在 transfer 组件之后，这样每个 judge 只需要处理一小部分数据；主要作用：</p><ol><li>接口 transfer 推送数据</li><li>分析数据，判断是否触发告警，需要告警则写入 redis</li></ol><p>部署一个 judge 实例处理50万~100万数据，用个5G~10G内存。</p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><blockquote><p>处理告警事件</p></blockquote><p>主要作用：</p><ol><li>从 redis 读取数据，触发动作（短信、邮件、回调等）</li><li>告警合并</li><li>已经发送的告警信息存入 MySQL，默认存7天</li></ol><p>alarm是个单点，因为未恢复的告警是放到alarm的内存中的，alarm还需要做报警合并。需要做好存活监控。</p><h2 id="HBS"><a href="#HBS" class="headerlink" title="HBS"></a>HBS</h2><blockquote><p>心跳服务器(Heartbeat Server)</p></blockquote><p>至少部署两个实例以保证可用性，一般一个实例可以搞定5000台机器；主要作用：</p><ol><li>所有 agent 都会连到 HBS，每分钟发一次心跳请求，并告知 agent 应该采集哪些端口和进程</li><li>维护业务机器的信息（host 表）</li><li>告知 judge 报警策略</li></ol><h2 id="Nodata"><a href="#Nodata" class="headerlink" title="Nodata"></a>Nodata</h2><blockquote><p>检测监控数据的上报异常</p></blockquote><p>主要作用：配置了nodata的采集项超时未上报数据，nodata生成一条默认的模拟数据</p><h2 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h2><blockquote><p>集群聚合</p></blockquote><p>主要作用：聚合某集群下的所有机器的某个指标的值，提供一种集群视角的监控体验</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><blockquote><p>定时任务</p></blockquote><p>主要作用：</p><ol><li>index更新。包括图表索引的全量更新 和 垃圾索引清理。</li><li>falcon服务组件的自身状态数据采集。定时任务采集了transfer、graph、task这三个服务的内部状态数据。</li><li>falcon自检控任务</li></ol><h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><ol><li>制定接口规范，以此接入各种监控数据</li><li>agent 自发现采集各种 Linux 性能指标，无需配置</li><li>由 HBS 下发各种采集指标、策略</li><li>支持 plugin；用户把插件提交到指定的 git repo，server端提供一个配置，哪些机器应该执行哪些插件，通过 HBS 把这个信息分发给 agent，agent 每隔一段时间去 git pull 这个 git repo，采集脚本就完成了分发。执行周期通过解析文件名来执行：60_action.sh，60s 执行一次。脚本执行完了，把输出打印到stdout，agent 截获之后 push 给 server</li></ol><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>Tag 是一种聚合手段，可以用更少的配置覆盖更多的监控项。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"endpoint"</span>: <span class="string">"qd-sadev-falcon-judge01.hd"</span>,</span><br><span class="line">    <span class="string">"metric"</span>: <span class="string">"latency"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: <span class="string">"department=sadev,project=falcon,module=judge,method=falcon.judge.rpc.send"</span>,</span><br><span class="line">    <span class="string">"value"</span>: <span class="number">10.2</span>,</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="number">1427204756</span>,</span><br><span class="line">    <span class="string">"step"</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="string">"counterType"</span>: <span class="string">"GAUGE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们这么配置：<code>latency/department=sadev all(#2) &gt; 20</code>，意味着对sadev这个部门的所有接口的latency都做了策略配置。</p><h2 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h2><p>同一个部门的机器，根据不同的业务对监控策略的要求是不一样的，比如业务 A 复杂高，load.1min &gt; 10 就报警，业务 B 复杂低，load.1min &gt; 5 就报警。若不支持模板继承，则需要配置两份策略，而模板继承就减少了此类工作量。</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>Open-falcon 把数据按照用途分成两类，一类是用来绘图的，一类是用户做数据挖掘的。关于绘图数据，在数据每次存入的时候，会自动进行采样、归档。我们的归档策略如下，历史数据保存5年。同时为了不丢失信息量，数据归档的时候，会按照平均值采样、最大值采样、最小值采样存三份。</p><p>对于原始数据，transfer会打一份到hbase，也可以直接使用opentsdb</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>参见<a href="http://book.open-falcon.org/zh_0_2/practice/deploy.html" rel="external nofollow noopener noreferrer" target="_blank">小米公司部署Open-Falcon的一些实践经验</a></p><h2 id="监控网络"><a href="#监控网络" class="headerlink" title="监控网络"></a>监控网络</h2><p><img src="/images/2019/06/dashboard.png" alt="dashboard"><br><img src="/images/2019/06/screen.png" alt="Screen"></p><h2 id="配置告警"><a href="#配置告警" class="headerlink" title="配置告警"></a>配置告警</h2><p><img src="/images/2019/06/template.png" alt="template"></p><h2 id="上报接口状态"><a href="#上报接口状态" class="headerlink" title="上报接口状态"></a>上报接口状态</h2><p>上报状态码、耗时等，可监控接口的健康、性能等。<br><img src="/images/2019/06/falcon.png" alt="falcon"></p><h1 id="可以做的改进"><a href="#可以做的改进" class="headerlink" title="可以做的改进"></a>可以做的改进</h1><p>参见<a href="https://tech.meituan.com/2017/02/24/mt-falcon-monitoring-system.html" rel="external nofollow noopener noreferrer" target="_blank">Mt-Falcon——Open-Falcon在美团点评的应用与实践</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://github.com/open-falcon/falcon-plus" rel="external nofollow noopener noreferrer" target="_blank">Open-Falcon 官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;监控系统概述&quot;&gt;&lt;a href=&quot;#监控系统概述&quot; class=&quot;headerlink&quot; title=&quot;监控系统概述&quot;&gt;&lt;/a&gt;监控系统概述&lt;/h1&gt;&lt;p&gt;在监控系统领域，相信大家都经历过 Zabbix 的时代；在公司刚起步，机器数量不多时，Zabbix 可以很好的满足我们的需求，但是随着业务的发展，Zabbix 的存储会成为主要的性能瓶颈，从而引发很多问题，增加运维成本。&lt;/p&gt;
&lt;p&gt;近些年来，随着互联网技术的不断发展，技术架构的不断演进，监控领域有两个我值得推荐的开源系统：一个是小米出品的 Open-Falcon，一个是基于 Google Borgmon 的开源实现 Prometheus。&lt;/p&gt;
&lt;p&gt;今天主要介绍下 Open-Falcon。&lt;br&gt;
    
    </summary>
    
      <category term="监控" scheme="http://www.helongfei.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="falcon" scheme="http://www.helongfei.com/tags/falcon/"/>
    
  </entry>
  
  <entry>
    <title>开源监控系统浅析</title>
    <link href="http://www.helongfei.com/2019/%E5%BC%80%E6%BA%90%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E6%B5%85%E6%9E%90/"/>
    <id>http://www.helongfei.com/2019/开源监控系统浅析/</id>
    <published>2019-06-09T12:04:00.000Z</published>
    <updated>2019-06-11T16:38:37.033Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="为什么需要监控系统？"><a href="#为什么需要监控系统？" class="headerlink" title="为什么需要监控系统？"></a>为什么需要监控系统？</h1><p>监控系统是整个运维体系的重要环节之一，主要服务于运维人员和开发人员；运维人员需要监控硬件、软件、网络等状态，做到故障预警、自动转移、自动恢复等，开发人员需要根据监控数据快速定位问题，提高服务的可用性。尤其是「微服务架构」，若没有监控系统，一但出现故障，定位问题就需要花费大量的时间。</p><a id="more"></a><h1 id="监控系统的核心"><a href="#监控系统的核心" class="headerlink" title="监控系统的核心"></a>监控系统的核心</h1><p>抽象来看，监控系统最主要的有两部分：监控指标、告警。</p><h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><p>为了实现我们的监控目的，我们需要制定一些监控指标，一般我们可以把监控指标分为：基础监控指标、业务监控指标。</p><p><strong>基础监控指标</strong></p><p>通常包括CPU、内存、磁盘、端口和进程等机器、网络相关的操作系统级别的信息，一般开源监控软件都提供此类指标的数据采集。</p><p><strong>业务监控指标</strong></p><p>一般都是由业务系统内部服务产生/上报，反应业务的健康状态。通常采集的有以下几类：</p><ol><li><strong>日志</strong>。日志是主要的监控数据来源。针对 PHP 来说，通常会采集 web server 的日志、php-fpm 慢日志、web 框架日志、数据库慢日志等。通过日志我们可以分析出大量有用的信息，比如：异常状态码的分布、接口请求量分布、请求延迟、用户地域分布、服务性能瓶颈等；最重要的是，若服务出现异常，我们可以通过日志快速的定位并复现问题。日志类的数据采集，一般监控软件都会提供日志采集插件，除此之外还可以使用 Elastic Stack 。</li><li><strong>接口</strong>。一般对外接口都需要提供健康接口；针对分布式服务，需要 Trace 系统来追踪整个请求链。</li><li><strong>命令行</strong>。一些开源软件提供本地的命令来输出监控指标，比如 Nginx、MySQL、PHP-FPM、Redis等</li><li><strong>上报</strong>。可以通过插件、埋点等方式主动 push 监控指标给监控系统。</li></ol><h2 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h2><p>告警最主要的是：收敛、可用性。</p><p><strong>收敛</strong></p><p>收敛问题主要体现在：告警信息多，关联告警多，运维期间不断告警。</p><p><strong>可用性</strong></p><p>可用性问题主要体现在：监控与告警耦合在一起。</p><h1 id="常见的开源监控系统"><a href="#常见的开源监控系统" class="headerlink" title="常见的开源监控系统"></a>常见的开源监控系统</h1><table><thead><tr><th>项目</th><th style="text-align:left">Prometheus</th><th style="text-align:left">Open-falcon</th><th style="text-align:left">Zabbix</th></tr></thead><tbody><tr><td>自动发现</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>Agent</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>SNMP</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>外部脚本</td><td style="text-align:left">NO</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>插件</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>告警</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td><td style="text-align:left">YES</td></tr><tr><td>数据储存方法</td><td style="text-align:left">TSDB</td><td style="text-align:left">MySQL/OpenTSDB/Redis</td><td style="text-align:left">MySQL</td></tr><tr><td>报表</td><td style="text-align:left">NO</td><td style="text-align:left">NO</td><td style="text-align:left">YES</td></tr><tr><td>开发语言</td><td style="text-align:left">Go</td><td style="text-align:left">Go Python</td><td style="text-align:left">C PHP</td></tr><tr><td>用户权限</td><td style="text-align:left">NO</td><td style="text-align:left">NO</td><td style="text-align:left">灵活分配</td></tr></tbody></table><p>在公司起步阶段，基本都选择 zabbix，但随着业务发展 zabbix 在数据存储上有很大的瓶颈；这时可以选择 open-falcon 或者 prometheus；若是微服务(容器化)，使用 k8s 作为容器编排，那首选 prometheus。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.jianshu.com/p/5b7072278b56" rel="external nofollow noopener noreferrer" target="_blank">监控系统选型Prometheus、TICK、Open-falcon、Zabbix</a></li><li><a href="https://blog.51cto.com/dangzhiqiang/2318130?source=dra" rel="external nofollow noopener noreferrer" target="_blank">常见开源告警系统对比分析(prometheus、open-falcon、zabbix)</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么需要监控系统？&quot;&gt;&lt;a href=&quot;#为什么需要监控系统？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要监控系统？&quot;&gt;&lt;/a&gt;为什么需要监控系统？&lt;/h1&gt;&lt;p&gt;监控系统是整个运维体系的重要环节之一，主要服务于运维人员和开发人员；运维人员需要监控硬件、软件、网络等状态，做到故障预警、自动转移、自动恢复等，开发人员需要根据监控数据快速定位问题，提高服务的可用性。尤其是「微服务架构」，若没有监控系统，一但出现故障，定位问题就需要花费大量的时间。&lt;/p&gt;
    
    </summary>
    
      <category term="监控" scheme="http://www.helongfei.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="falcon" scheme="http://www.helongfei.com/tags/falcon/"/>
    
      <category term="prometheus" scheme="http://www.helongfei.com/tags/prometheus/"/>
    
      <category term="zabbix" scheme="http://www.helongfei.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Laravel自定义用户权限校验</title>
    <link href="http://www.helongfei.com/2017/laravel%E8%87%AA%E5%AE%9A%E4%B9%89%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/"/>
    <id>http://www.helongfei.com/2017/laravel自定义用户权限校验/</id>
    <published>2017-12-29T16:05:00.000Z</published>
    <updated>2017-12-29T16:48:41.499Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在现实的架构中，帐号体系往往会单独维护，应用需要鉴权的时候会请求用户中心接口，而<code>laravel</code>使用<code>auth</code>中间件时默认采用的是<code>session</code>进行鉴权，不能满足我们的需求，所以需要自定义权限校验。</p><h1 id="Auth-中间件的工作原理"><a href="#Auth-中间件的工作原理" class="headerlink" title="Auth 中间件的工作原理"></a><code>Auth</code> 中间件的工作原理</h1><a id="more"></a><p>首先，在 <code>app/Http/Kernel.php</code> 中，发现 :<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $routeMiddleware = [</span><br><span class="line">       <span class="string">'auth'</span> =&gt; \Illuminate\Auth\Middleware\Authenticate::class,</span><br><span class="line">       <span class="string">'auth.basic'</span> =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,</span><br><span class="line">       ...</span><br><span class="line">   ];</span><br></pre></td></tr></table></figure></p><p>然后，跟踪到 <code>vendor/laravel/framework/src/Illuminate/Auth/AuthManager.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">guard</span><span class="params">($name = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   $name = $name ?: <span class="keyword">$this</span>-&gt;getDefaultDriver();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;guards[$name])</span><br><span class="line">               ? <span class="keyword">$this</span>-&gt;guards[$name]</span><br><span class="line">               : <span class="keyword">$this</span>-&gt;guards[$name] = <span class="keyword">$this</span>-&gt;resolve($name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultDriver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 注意这行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;app[<span class="string">'config'</span>][<span class="string">'auth.defaults.guard'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，查看 <code>config/auth.php</code> :<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="string">'defaults'</span> =&gt; [</span><br><span class="line">       <span class="string">'guard'</span> =&gt; <span class="string">'web'</span>, <span class="comment">// 注意这行</span></span><br><span class="line">       <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">   ],</span><br><span class="line">...</span><br><span class="line"><span class="string">'guards'</span> =&gt; [</span><br><span class="line">       <span class="string">'web'</span> =&gt; [</span><br><span class="line">           <span class="string">'driver'</span> =&gt; <span class="string">'session'</span>,</span><br><span class="line">           <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">       ],</span><br><span class="line">       ...</span><br><span class="line">   ],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由此可见，默认使用的<code>guard</code>是<code>web</code>，驱动是<code>session</code>；到此已经很明确了，我们需要做的只是新建一个<code>guard</code>。</p><p>具体如何创建<code>guard</code>？<br>见官方文档：<a href="https://laravel.com/docs/5.5/authentication#adding-custom-guards" rel="external nofollow noopener noreferrer" target="_blank">https://laravel.com/docs/5.5/authentication#adding-custom-guards</a></p><h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h1><ul><li>创建 <code>guard</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Auth</span>\<span class="title">GuardHelpers</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Auth</span>\<span class="title">Guard</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KohanaGuard</span> <span class="keyword">implements</span> <span class="title">Guard</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">use</span> <span class="title">GuardHelpers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> $request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;request = $request;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the currently authenticated user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \Illuminate\Contracts\Auth\Authenticatable|null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">user</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">          <span class="comment">// 校验规则</span></span><br><span class="line">          <span class="comment">// 成功返回 User Model 对象</span></span><br><span class="line">          <span class="comment">// 失败返回 null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Validate a user's credentials.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array $credentials</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(array $credentials = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Implement validate() method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加到 <code>app/Providers/AuthServiceProvider.php</code>:</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;registerPolicies();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注册 kohana 的 guard</span></span><br><span class="line">   \Auth::extend(<span class="string">'kohana'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($app, $name, array $config)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> KohanaGuard($app[<span class="string">'request'</span>]);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改 <code>config/auth.php</code><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="string">'defaults'</span> =&gt; [</span><br><span class="line">    <span class="string">'guard'</span> =&gt; <span class="string">'kohana'</span>, <span class="comment">// 注意这行</span></span><br><span class="line">    <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line"><span class="string">'guards'</span> =&gt; [</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 以下为新增</span></span><br><span class="line">   <span class="string">'kohana'</span> =&gt; [</span><br><span class="line">     <span class="string">'driver'</span> =&gt; <span class="string">'kohana'</span>,</span><br><span class="line">     <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">   ],</span><br><span class="line">],</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在现实的架构中，帐号体系往往会单独维护，应用需要鉴权的时候会请求用户中心接口，而&lt;code&gt;laravel&lt;/code&gt;使用&lt;code&gt;auth&lt;/code&gt;中间件时默认采用的是&lt;code&gt;session&lt;/code&gt;进行鉴权，不能满足我们的需求，所以需要自定义权限校验。&lt;/p&gt;
&lt;h1 id=&quot;Auth-中间件的工作原理&quot;&gt;&lt;a href=&quot;#Auth-中间件的工作原理&quot; class=&quot;headerlink&quot; title=&quot;Auth 中间件的工作原理&quot;&gt;&lt;/a&gt;&lt;code&gt;Auth&lt;/code&gt; 中间件的工作原理&lt;/h1&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.helongfei.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://www.helongfei.com/tags/php/"/>
    
      <category term="laravel" scheme="http://www.helongfei.com/tags/laravel/"/>
    
  </entry>
  
  <entry>
    <title>CI 框架总结</title>
    <link href="http://www.helongfei.com/2016/cikuang-jia-zong-jie/"/>
    <id>http://www.helongfei.com/2016/cikuang-jia-zong-jie/</id>
    <published>2016-03-26T19:09:54.000Z</published>
    <updated>2017-11-11T07:52:27.045Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>本文主要是参考2.2.6的源码</p></blockquote><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><p>使用 &amp;get_instance(); 可以引用所有已加载的类。<br><a id="more"></a></p><h1 id="中文手册"><a href="#中文手册" class="headerlink" title="中文手册"></a>中文手册</h1><p><a href="http://codeigniter.org.cn/userguide2/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://codeigniter.org.cn/userguide2/index.html</a>  </p><h1 id="框架运行图解"><a href="#框架运行图解" class="headerlink" title="框架运行图解"></a>框架运行图解</h1><h2 id="运行流程图"><a href="#运行流程图" class="headerlink" title="运行流程图"></a>运行流程图</h2><img src="/images/2016/0327/CI.png" class="center"><h2 id="运行生命周期"><a href="#运行生命周期" class="headerlink" title="运行生命周期"></a>运行生命周期</h2><img src="/images/2016/0327/CI2.png" class="center"><h1 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h1><h2 id="Controller-中"><a href="#Controller-中" class="headerlink" title="Controller 中"></a>Controller 中</h2><ul><li><code>_remap</code> 方法（接管路由）</li><li><code>_output</code> 方法（接管输出）</li><li><code>_</code>前缀的方法名都会被路由屏蔽</li></ul><h1 id="如何扩展框架？"><a href="#如何扩展框架？" class="headerlink" title="如何扩展框架？"></a>如何扩展框架？</h1><h2 id="扩展-替换-core-类"><a href="#扩展-替换-core-类" class="headerlink" title="扩展/替换 core 类"></a>扩展/替换 core 类</h2><blockquote><p>此类都是在系统使用的核心类，常用的是扩展控制器类</p></blockquote><p>在 application/core 下新建文件</p><ul><li><p>扩展</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MY_controller</span> <span class="keyword">extends</span> <span class="title">CI_controller</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>替换</p>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CI_controller</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-新建-替换-扩展类库"><a href="#使用-新建-替换-扩展类库" class="headerlink" title="使用/新建/替换/扩展类库"></a>使用/新建/替换/扩展类库</h2><ol><li><p>使用内置</p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;library(<span class="string">'name'</span>);</span><br></pre></td></tr></table></figure></li><li><p>建立新的类<br> 在 applicatioin/libraries 目录下</p></li><li><p>扩展已有类<br> 在 applicatioin/libraries 目录下，使用定义好的子类前缀，并继承父类<br> 比如扩展 email：  </p> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MY_Email</span> <span class="keyword">extends</span> <span class="title">CI_Email</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>替换已有类<br> 在 applicatioin/libraries 目录下，声明和默认的类名一样的类</li></ol><h2 id="使用-新建适配器"><a href="#使用-新建适配器" class="headerlink" title="使用/新建适配器"></a>使用/新建适配器</h2><ul><li>内置</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;driver(<span class="string">'some_parent'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;some_parent-&gt;some_method();</span><br><span class="line"><span class="keyword">$this</span>-&gt;some_parent-&gt;child_one-&gt;some_method();</span><br></pre></td></tr></table></figure><ul><li>自定义</li></ul><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/application/libraries/Driver_name</span><br><span class="line">  Driver_name.php</span><br><span class="line">  drivers</span><br><span class="line">  Driver_name_subclass_1.php</span><br><span class="line">  Driver_name_subclass_2.php</span><br><span class="line">  Driver_name_subclass_3.php</span><br></pre></td></tr></table></figure><h2 id="集成自己的独立应用"><a href="#集成自己的独立应用" class="headerlink" title="集成自己的独立应用"></a>集成自己的独立应用</h2><p>目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/application/third_party/foo_bar</span><br><span class="line">config/</span><br><span class="line">helpers/</span><br><span class="line">language/</span><br><span class="line">libraries/</span><br><span class="line">models/</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;add_package_path(APPPATH.<span class="string">'third_party/foo_bar/'</span>);</span><br><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;library(<span class="string">'foo_bar'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;remove_package_path(APPPATH.<span class="string">'third_party/foo_bar/'</span>);</span><br></pre></td></tr></table></figure><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol><li>默认保存 SQL；cli 模式下会内存溢出;修复方式如下：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在配置文件中增加：</span><br><span class="line">$db[<span class="string">'default'</span>][<span class="string">'save_queries'</span>] = <span class="keyword">false</span>;</span><br><span class="line">或者在代码里增加:</span><br><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;database();</span><br><span class="line"><span class="keyword">$this</span>-&gt;db-&gt;save_queries = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要是参考2.2.6的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;设计思想&quot;&gt;&lt;a href=&quot;#设计思想&quot; class=&quot;headerlink&quot; title=&quot;设计思想&quot;&gt;&lt;/a&gt;设计思想&lt;/h1&gt;&lt;p&gt;使用 &amp;amp;get_instance(); 可以引用所有已加载的类。&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.helongfei.com/categories/PHP/"/>
    
    
      <category term="php" scheme="http://www.helongfei.com/tags/php/"/>
    
      <category term="CI" scheme="http://www.helongfei.com/tags/CI/"/>
    
  </entry>
  
</feed>
