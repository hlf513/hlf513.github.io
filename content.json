{"pages":[{"title":"About","date":"2017-11-05T11:04:38.000Z","path":"about/index.html","text":""},{"title":"Categories","date":"2017-11-05T11:03:47.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2017-11-05T11:02:00.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"使用 OpenResty 实现 Grafana 免登录","date":"2019-06-20T10:44:00.000Z","path":"2019/使用-openresty-实现-grafana-免登录/","text":"概述公司内部都有管理后台，一般都会把第三方软件集成到后台，收敛登录入口。 本文主要介绍一种集成 Grafana 的方法。 问题假设，只有一个 token ，通过这个 token 可以获取到用户信息，在这种情况下，怎么可以免登录进入 Grafana？ 例：访问：http://grafana.com?token=xxxxxxx 后，不应该跳转到 http://grafana.com/login ，而应该直接进入 http://grafana.com/home 基本思路通过查看文档，可以发现 Grafana 支持多种权限认证；但没有一个能完美解决我们问题的方案；唯一比较接近的是 Auth Proxy，说是可以在 Grafana 外部进行权限验证，经过通读文档和试验，发现其本质是：通过 web server 校验后，在每个请求上增加一个 header (默认 X-WEBAUTH-USER)来实现免登录\b；文档中的示例是通过 htpasswd 来实现的权限验证，那自然想到可以通过 OpenResty \b进行权限校验。 假设 token 对应的用户信息存在 Redis 中，基本流程如下： 实现细节Auth Proxy本质是增加一个header（默认 X-WEBAUTH-USER）； Grafana 开启Auth Proxy；配置：12345678910[auth.proxy]enabled = true; defalut header nameheader_name = X-WEBAUTH-USER; username or emailheader_property = username; 自动注册auto_sign_up = false; 白名单whitelist = 127.0.0.1 OpenResty\bOpenResty的配置为：123456789101112131415161718192021server &#123; listen 80; server_name grafana.com; location / &#123; content_by_lua_file \"/usr/local/etc/openresty/conf.d/grafana.lua\"; # 本质是\b为了加这个 header # proxy_set_header X-WEBAUTH-USER \"longfeihe\"; &#125; location @grafana &#123; proxy_pass http://127.0.0.1:3000; &#125; # 若使用 url 接口鉴权，则开启此 location #location ^~ /proxy/ &#123; # internal; # 内部请求 # proxy_pass http://someone-proxy.com/; # 必须有 / # proxy_set_header Accept \"*/*\"; #&#125;&#125; grafana.lua123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121-- config redis startlocal redisIp = '127.0.0.1'local redisPort = '6379'-- config redis endlocal cjson = require \"cjson\"local redis = require \"resty.redis\"local aes = require \"resty.aes\"local function getToken() local args = ngx.req.get_uri_args() local token = args['token'] return tokenendfunction conRedis(ip, port) local red = redis.new() local ok, err = red:connect(ip, port) red:set_timeout(1000) -- 1s if not ok then ngx.log(ngx.ERR, 'connect redis fail') ngx.exit(ngx.HTTP_SERVICE_UNAVAILABLE) end ngx.log(ngx.INFO, 'connect redis success') return redendlocal function getUsernameByRedis(token) local red = conRedis(redisIp, redisPort) token = ngx.md5(token .. '_sso') ngx.log(ngx.INFO, 'fetch redis key:' .. token) local value = red:get(token) closeRedis(red) if value ~= ngx.null then obj = cjson.decode(value) local username = obj['username'] return username end returnend-- 使用 url 鉴权function getUsernameByUrl(token) local uri = \"/proxy/get-user-info\" -- 这里接口地址按实际情况进行修改 --ngx.req.set_header(\"X-TOKEN\", token) res = ngx.location.capture(uri, &#123; method = ngx.HTTP_POST &#125;) if res.body then local data = cjson.decode(res.body) if data[\"code\"] ~= 0 then ngx.log(ngx.ERR, \"request model for get user info was failed; msg:\" .. data[\"message\"]) ngx.exit(ngx.HTTP_BAD_GATEWAY) end local email = data[\"data\"][\"email\"] return email else ngx.log(ngx.ERR, \"request model for get user info was failed; code:\" .. res.status) ngx.exit(ngx.HTTP_BAD_GATEWAY) endendfunction closeRedis(redis) local ok, err = redis:close() if not ok then ngx.log(ngx.ERR, 'close redis connect fail') return end ngx.log(ngx.INFO, 'close redis connect success')endlocal function setHeader(username) ngx.log(ngx.INFO, 'X-WEBAUTH-USER:' .. username) ngx.req.set_header(\"X-WEBAUTH-USER\", username)endlocal function setCookie(username) ngx.header['Set-Cookie'] = &#123; 'token=' .. encrypt(username) &#125;endlocal function getUsernameByCookie() local token = ngx.var.cookie_token return decrypt(token)endlocal function logout() if ngx.re.match(ngx.var.request_uri, \"logout\") then ngx.header['Set-Cookie'] = &#123; 'token=' &#125; endendfunction encrypt(encryptString) local aes_128_cbc_md5 = aes:new(\"AKeyForAES\") return ngx.encode_base64(aes_128_cbc_md5:encrypt(encryptString))endfunction decrypt(decryptString) local aes_128_cbc_md5 = aes:new(\"AKeyForAES\") local decrypt = ngx.decode_base64(decryptString) return aes_128_cbc_md5:decrypt(decrypt)end-- mainlogout()local token = getToken()if token then ngx.log(ngx.INFO, 'get token:' .. token) local username = getUsernameByRedis(token) if username then setHeader(username) setCookie(username) end ngx.exec(\"@grafana\")else local username = getUsernameByCookie() if username then setHeader(username) end ngx.exec(\"@grafana\")end 参考资料 Auth Proxy Authentication OpenResty","tags":[{"name":"grafana","slug":"grafana","permalink":"http://www.helongfei.com/tags/grafana/"},{"name":"openresty","slug":"openresty","permalink":"http://www.helongfei.com/tags/openresty/"},{"name":"lua","slug":"lua","permalink":"http://www.helongfei.com/tags/lua/"}],"categories":[{"name":"监控","slug":"监控","permalink":"http://www.helongfei.com/categories/监控/"}]},{"title":"Open-Falcon 浅析","date":"2019-06-11T15:44:00.000Z","path":"2019/open-falcon-浅析/","text":"监控系统概述在监控系统领域，相信大家都经历过 Zabbix 的时代；在公司刚起步，机器数量不多时，Zabbix 可以很好的满足我们的需求，但是随着业务的发展，Zabbix 的存储会成为主要的性能瓶颈，从而引发很多问题，增加运维成本。 近些年来，随着互联网技术的不断发展，技术架构的不断演进，监控领域有两个我值得推荐的开源系统：一个是小米出品的 Open-falcon，一个是基于 Google Borgmon 的开源实现 Prometheus。 今天主要介绍下 Open-falcon。 Open-falcon 有如下特点： 强大灵活的数据采集：自动发现，支持falcon-agent、snmp、支持用户主动push、用户自定义插件支持、opentsdb data model like（timestamp、endpoint、metric、key-value tags） 水平扩展能力：支持每个周期上亿次的数据采集、告警判定、历史数据存储和查询 高效率的告警策略管理：高效的portal、支持策略模板、模板继承和覆盖、多种告警方式、支持callback调用 人性化的告警设置：最大告警次数、告警级别、告警恢复通知、告警暂停、不同时段不同阈值、支持维护周期 高效率的graph组件：单机支撑200万metric的上报、归档、存储（周期为1分钟） 高效的历史数据query组件：采用rrdtool的数据归档策略，秒级返回上百个metric一年的历史数据 dashboard：多维度的数据展示，用户自定义Screen 高可用：整个系统无核心单点，易运维，易部署，可水平扩展 开发语言： 整个系统的后端，全部golang编写，portal和dashboard使用python编写。 简而言之：Open-falcon 是一个模块化、高可用、高性能、支持水平扩展的监控告警系统，支持机器监控、业务监控、各种开源软件的监控。 架构 Agent 数据采集组件 部署在业务机器上，主要作用： 自动采集预先定义的各种采集项（机器级别的监控指标） agent 还提供一个 HTTP 接口（/v1/push），用于接收用户自定义上报数据 每隔60秒，通过 JsonRPC push 数据到 Transfer 模块（使用长连接）。 Transfer 数据转发服务 主要作用： 接收 agent 上报的数据 按照哈希规则进行数据分片，并将分片后的数据分别 push 给 graph、judge 等组件 Graph 存储绘图数据、历史数据 主要作用： 接口 transfer 推送数据 处理 API 组件的查询请求、返回绘图数据 API 绘图数据的查询接口 主要作用：根据一致性哈希算法去相应的 graph 实例查询不同监控项的数据，汇总后返回 Dashboard 面向用户的查询界面 Judge 告警判断 因为数据量太大，此组件放在 transfer 组件之后，这样每个 judge 只需要处理一小部分数据；主要作用： 接口 transfer 推送数据 分析数据，判断是否触发告警，需要告警则写入 redis 部署一个 judge 实例处理50万~100万数据，用个5G~10G内存。 Alarm 处理告警事件 主要作用： 从 redis 读取数据，触发动作（短信、邮件、回调等） 告警合并 已经发送的告警信息存入 MySQL，默认存7天 alarm是个单点，因为未恢复的告警是放到alarm的内存中的，alarm还需要做报警合并。需要做好存活监控。 HBS 心跳服务器(Heartbeat Server) 至少部署两个实例以保证可用性，一般一个实例可以搞定5000台机器；主要作用： 所有 agent 都会连到 HBS，每分钟发一次心跳请求，并告知 agent 应该采集哪些端口和进程 维护业务机器的信息（host 表） 告知 judge 报警策略 Nodata 检测监控数据的上报异常 主要作用：配置了nodata的采集项超时未上报数据，nodata生成一条默认的模拟数据 Aggregator 集群聚合 主要作用：聚合某集群下的所有机器的某个指标的值，提供一种集群视角的监控体验 Task 定时任务 主要作用： index更新。包括图表索引的全量更新 和 垃圾索引清理。 falcon服务组件的自身状态数据采集。定时任务采集了transfer、graph、task这三个服务的内部状态数据。 falcon自检控任务 设计理念数据采集 制定接口规范，以此接入各种监控数据 agent 自发现采集各种 Linux 性能指标，无需配置 由 HBS 下发各种采集指标、策略 支持 plugin；用户把插件提交到指定的 git repo，server端提供一个配置，哪些机器应该执行哪些插件，通过 HBS 把这个信息分发给 agent，agent 每隔一段时间去 git pull 这个 git repo，采集脚本就完成了分发。执行周期通过解析文件名来执行：60_action.sh，60s 执行一次。脚本执行完了，把输出打印到stdout，agent 截获之后 push 给 server TagTag 是一种聚合手段，可以用更少的配置覆盖更多的监控项。例如：123456789&#123; \"endpoint\": \"qd-sadev-falcon-judge01.hd\", \"metric\": \"latency\", \"tags\": \"department=sadev,project=falcon,module=judge,method=falcon.judge.rpc.send\", \"value\": 10.2, \"timestamp\": 1427204756, \"step\": 60, \"counterType\": \"GAUGE\"&#125; 如果我们这么配置：latency/department=sadev all(#2) &gt; 20，意味着对sadev这个部门的所有接口的latency都做了策略配置。 模板继承同一个部门的机器，根据不同的业务对监控策略的要求是不一样的，比如业务 A 复杂高，load.1min &gt; 10 就报警，业务 B 复杂低，load.1min &gt; 5 就报警。若不支持模板继承，则需要配置两份策略，而模板继承就减少了此类工作量。 数据存储Open-falcon 把数据按照用途分成两类，一类是用来绘图的，一类是用户做数据挖掘的。关于绘图数据，在数据每次存入的时候，会自动进行采样、归档。我们的归档策略如下，历史数据保存5年。同时为了不丢失信息量，数据归档的时候，会按照平均值采样、最大值采样、最小值采样存三份。 对于原始数据，transfer会打一份到hbase，也可以直接使用opentsdb 使用\b示例监控网络 配置告警 上报接口状态上报状态码、耗时等，可监控接口的健康、性能等。 参考资料 open-falcon","tags":[{"name":"falcon","slug":"falcon","permalink":"http://www.helongfei.com/tags/falcon/"}],"categories":[{"name":"监控","slug":"监控","permalink":"http://www.helongfei.com/categories/监控/"}]},{"title":"开源监控系统浅析","date":"2019-06-09T12:04:00.000Z","path":"2019/开源监控系统浅析/","text":"为什么需要监控系统？监控系统是整个运维体系的重要环节之一，主要服务于运维人员和开发人员；运维人员需要监控硬件、软件、网络等状态，做到故障预警、自动转移、自动恢复等，开发人员需要根据监控数据快速定位问题，提高服务的可用性。尤其是「微服务架构」，若没有监控系统，一但出现故障，定位问题就需要花费大量的时间。 监控系统的核心抽象来看，监控系统最主要的有两部分：监控指标、告警。 监控指标为了实现我们的监控目的，我们需要制定一些监控指标，一般我们可以把监控指标分为：基础监控指标、业务监控指标。 基础监控指标 通常包括CPU、内存、磁盘、端口和进程等机器、网络相关的操作系统级别的信息，一般开源监控软件都提供此类指标的数据采集。 业务监控指标 一般都是由业务系统内部服务产生/上报，反应业务的健康状态。通常采集的有以下几类： 日志。日志是主要的监控数据来源。针对 PHP 来说，通常会采集 web server 的日志、php-fpm 慢日志、web 框架日志、数据库慢日志等。通过日志我们可以分析出大量有用的信息，比如：异常状态码的分布、接口请求量分布、请求延迟、用户地域分布、服务性能瓶颈等；最重要的是，若服务出现异常，我们可以通过日志快速的定位并复现问题。日志类的数据采集，一般监控软件都会提供日志采集插件，除此之外还可以使用 Elastic Stack 。 接口。一般对外接口都需要提供健康接口；针对分布式服务，需要 Trace 系统来追踪整个请求链。 命令行。一些开源软件提供本地的命令来输出监控指标，比如 Nginx、MySQL、PHP-FPM、Redis等 上报。可以通过插件、埋点等方式主动 push 监控指标给监控系统。 告警告警最主要的是：收敛、可用性。 收敛 收敛问题主要体现在：告警信息多，关联告警多，运维期间不断告警。 可用性 可用性问题主要体现在：监控与告警耦合在一起。 常见的开源监控系统 项目 Prometheus Open-falcon Zabbix 自动发现 YES YES YES Agent YES YES YES SNMP YES YES YES 外部脚本 NO YES YES 插件 YES YES YES 告警 YES YES YES 数据储存方法 TSDB MySQL/OpenTSDB/Redis MySQL 报表 NO NO YES 开发语言 Go Go Python C PHP 用户权限 NO NO 灵活分配 在公司起步阶段，基本都选择 zabbix，但随着业务发展 zabbix 在数据存储上有很大的瓶颈；这时可以选择 open-falcon 或者 prometheus；若是微服务(容器化)，使用 k8s 作为容器编排，那首选 prometheus。 参考资料 监控系统选型Prometheus、TICK、Open-falcon、Zabbix 常见开源告警系统对比分析(prometheus、open-falcon、zabbix)","tags":[{"name":"falcon","slug":"falcon","permalink":"http://www.helongfei.com/tags/falcon/"},{"name":"prometheus","slug":"prometheus","permalink":"http://www.helongfei.com/tags/prometheus/"},{"name":"zabbix","slug":"zabbix","permalink":"http://www.helongfei.com/tags/zabbix/"}],"categories":[{"name":"监控","slug":"监控","permalink":"http://www.helongfei.com/categories/监控/"}]},{"title":"Laravel自定义用户权限校验","date":"2017-12-29T16:05:00.000Z","path":"2017/laravel自定义用户权限校验/","text":"背景在现实的架构中，帐号体系往往会单独维护，应用需要鉴权的时候会请求用户中心接口，而laravel使用auth中间件时默认采用的是session进行鉴权，不能满足我们的需求，所以需要自定义权限校验。 Auth 中间件的工作原理 首先，在 app/Http/Kernel.php 中，发现 :12345protected $routeMiddleware = [ 'auth' =&gt; \\Illuminate\\Auth\\Middleware\\Authenticate::class, 'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, ... ]; 然后，跟踪到 vendor/laravel/framework/src/Illuminate/Auth/AuthManager.php 123456789101112131415public function guard($name = null)&#123; $name = $name ?: $this-&gt;getDefaultDriver(); return isset($this-&gt;guards[$name]) ? $this-&gt;guards[$name] : $this-&gt;guards[$name] = $this-&gt;resolve($name);&#125;...public function getDefaultDriver()&#123; // 注意这行 return $this-&gt;app['config']['auth.defaults.guard'];&#125; 然后，查看 config/auth.php :123456789101112131415...'defaults' =&gt; [ 'guard' =&gt; 'web', // 注意这行 'passwords' =&gt; 'users', ],...'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], ... ],... 由此可见，默认使用的guard是web，驱动是session；到此已经很明确了，我们需要做的只是新建一个guard。 具体如何创建guard？见官方文档：https://laravel.com/docs/5.5/authentication#adding-custom-guards 举个例子 创建 guard 12345678910111213141516171819202122232425262728293031323334353637383940414243namespace App;use Illuminate\\Auth\\GuardHelpers;use Illuminate\\Contracts\\Auth\\Guard;use Illuminate\\Http\\Request;class KohanaGuard implements Guard&#123; use GuardHelpers; protected $request; public function __construct(Request $request) &#123; $this-&gt;request = $request; &#125; /** * Get the currently authenticated user. * * @return \\Illuminate\\Contracts\\Auth\\Authenticatable|null * @throws \\Exception */ public function user() &#123; // 校验规则 // 成功返回 User Model 对象 // 失败返回 null &#125; /** * Validate a user's credentials. * * @param array $credentials * * @return bool */ public function validate(array $credentials = []) &#123; // TODO: Implement validate() method. &#125;&#125; 添加到 app/Providers/AuthServiceProvider.php: 12345678910public function boot()&#123; $this-&gt;registerPolicies(); //注册 kohana 的 guard \\Auth::extend('kohana', function ($app, $name, array $config) &#123; return new KohanaGuard($app['request']); &#125;);&#125; 修改 config/auth.php123456789101112131415...'defaults' =&gt; [ 'guard' =&gt; 'kohana', // 注意这行 'passwords' =&gt; 'users',],...'guards' =&gt; [ ... // 以下为新增 'kohana' =&gt; [ 'driver' =&gt; 'kohana', 'provider' =&gt; 'users', ],],...","tags":[{"name":"php","slug":"php","permalink":"http://www.helongfei.com/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"http://www.helongfei.com/tags/laravel/"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.helongfei.com/categories/PHP/"}]},{"title":"CI 框架总结","date":"2016-03-26T19:09:54.000Z","path":"2016/cikuang-jia-zong-jie/","text":"本文主要是参考2.2.6的源码 设计思想使用 &amp;get_instance(); 可以引用所有已加载的类。 中文手册http://codeigniter.org.cn/userguide2/index.html 框架运行图解运行流程图 运行生命周期 开发注意事项Controller 中 _remap 方法（接管路由） _output 方法（接管输出） _前缀的方法名都会被路由屏蔽 如何扩展框架？扩展/替换 core 类 此类都是在系统使用的核心类，常用的是扩展控制器类 在 application/core 下新建文件 扩展 1class MY_controller extends CI_controller&#123;&#125; 替换 1class CI_controller&#123;&#125; 使用/新建/替换/扩展类库 使用内置 1$this-&gt;load-&gt;library('name'); 建立新的类 在 applicatioin/libraries 目录下 扩展已有类 在 applicatioin/libraries 目录下，使用定义好的子类前缀，并继承父类 比如扩展 email： 1class MY_Email extends CI_Email&#123;&#125; 替换已有类 在 applicatioin/libraries 目录下，声明和默认的类名一样的类 使用/新建适配器 内置 123$this-&gt;load-&gt;driver('some_parent');$this-&gt;some_parent-&gt;some_method();$this-&gt;some_parent-&gt;child_one-&gt;some_method(); 自定义 目录结构： 123456/application/libraries/Driver_name Driver_name.php drivers Driver_name_subclass_1.php Driver_name_subclass_2.php Driver_name_subclass_3.php 集成自己的独立应用目录结构： 123456/application/third_party/foo_barconfig/helpers/language/libraries/models/ 使用方法： 1234$this-&gt;load-&gt;add_package_path(APPPATH.'third_party/foo_bar/');$this-&gt;load-&gt;library('foo_bar');...$this-&gt;load-&gt;remove_package_path(APPPATH.'third_party/foo_bar/'); 坑 默认保存 SQL；cli 模式下会内存溢出;修复方式如下： 12345在配置文件中增加：$db['default']['save_queries'] = false;或者在代码里增加:$this-&gt;load-&gt;database();$this-&gt;db-&gt;save_queries = false;","tags":[{"name":"php","slug":"php","permalink":"http://www.helongfei.com/tags/php/"},{"name":"CI","slug":"CI","permalink":"http://www.helongfei.com/tags/CI/"}],"categories":[{"name":"PHP","slug":"PHP","permalink":"http://www.helongfei.com/categories/PHP/"}]}]}